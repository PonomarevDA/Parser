# Parser. Дерево синтаксического разбора

## Введение
Рассмотрим следующую ситуацию: есть некоторая известная формула с несколькими переменными. Подстановкой значений этих переменных в данную
формулу можно однозначно получить ответ (число).
Введем 2 понятия:

1. Прямая задача - когда известны формула и переменные, и нужно найти ответ. Такую задачу решает терминал.
2. Обратная задача - когда известны формула и ответ, нужно найти значения переменных. Такую задачу решает стенд.

В общем случае вторая задача не имеет решения, поскольку теоретически могут возникнуть нерешаемые формулы вида:

    d0 + d1 = value,

где d0 и d1 - переменные, а value - ответ.

На практике формулы будут иметь однозначные решения, однако замечены исключения.

## Описание файлов и их применения

Предполагается, что данный код будет интегрирован в прошивку стенда, а именно в функции файла obd.cpp:

- Init() - инициализация  протокола obd, парсер формул из конфигуратора. Сюда будет включена функция [CreateTree()](https://github.com/PonomarevDA/Parser/blob/c7f0cda16bb13a00426681c0618f01184bc1e3de/obd.cpp#L6-L64)

- Do() - обработка текущего состояния. В эту функцию будет включен один из методов DoReverseCalculate...(), которые описаны ниже

Список файлов с кратким описание представлен в таблице 1.

*Таблица 1.*

| Файл                | Краткое описание   |
| ------------------- |:------------------:|
| obd.cpp и .hpp      | Файлы с инициализацией исходных данных и реализацией методов прямого и обратного расчета |
| obd_test.cpp и .hpp | Файлы с тестовыми кейсами данных методов                                                 |
| data_structures.hpp | Заголовочный файл со структурами данными, подключен в файл obd.cpp                       |
| tree.cpp            | Реализация методов класса Tree                                                           |
| stack.cpp           | Реализация методов класса Stack                                                          |


Для проведения тестов вне стенда создан класс TestOBD.

Чтобы им воспользоваться, достаточно создать пустой проект, добавить в него все указанные в таблице файлы, создать main.cpp файл,
подключить к нему все заголовочные файлы, в main() функции создать объект класса TestOBD и вызвать метод TestCalculationReverse(). 

    #include "data_structures.hpp"
    #include "obd.hpp"
    #include "obd_test.hpp"

    int main()
    {
        TestOBD testOBD;
        testOBD.TestCalculationReverse();
    }

## Описание дерева

Дерево представляет из себя набор узлов - структур, обладающих следующими полями:

1. Value - байт формулы;

2. ChildsCount - кол-во потомков;

3. ChildsArr - массив из трех указателей на узлы-потомки;

4. Parent - указатель на узел-потомка. Если родителя нет, то указывает на nullptr.

Дерево строится в порядке, обратном расположению элементов массива байт Formula, т.е. начиная со старшего элемента.

Вводятся следующие понятия во избежаении путаницы:

- Базовый узел (base) - родитель всех родителей или узел (обычно оператор), с которого начинается решение обратной задачи расчета.

- Висячий узел (apex) - узел, который связан только с одним другим узлом. Графически висячие узлы располагаются на самом нижнем уровне, поскольку не имеют потомков. Данные узлы являются операндами.


## Описание методов решения обратной задачи

Предлагается 3 метода решения обратной задачи:



**1 Метод перебора [DoReverseCalculateWithBruteForce()](https://github.com/PonomarevDA/Parser/blob/c7f0cda16bb13a00426681c0618f01184bc1e3de/obd.cpp#L228-L281)**

+Данный метод позволяет найтии решение обратной задачи. В случае, если решение не единственное, он вернет первое найденное решение.

-Максимальное время решения задачи данным методом для 3-ех переменных ~ 7 секунд. Для 4-ех может превысить 30 минут...

-Метод не справляется при выполнении операции обратной умножению. Поскольку происходит округление, метод не может дать в соответствие
какую-либо величину.



**2 Метод половинного деления [DoReverseCalculateWithMethodDichotomy()](https://github.com/PonomarevDA/Parser/blob/c7f0cda16bb13a00426681c0618f01184bc1e3de/obd.cpp#L284-L372)**

+Если возможно, очень быстро находит решение.

+Данный метод можно заменить, например, на метод золотого сечения, тем самым сделать его быстрее.

-В ситуаях, когда функция не монотонна, метод может не найти решения и зависнуть. Пример подобных формул:

    (d0 == 10) && (d0 == 20)

Как следствие из минуса, метод дает положительный результат только в половине формул.


**3 Метод решения обратной задачи с помощью дерева [DoReverseCalculateWithTree()](https://github.com/PonomarevDA/Parser/blob/c7f0cda16bb13a00426681c0618f01184bc1e3de/obd.cpp#L135-L225)**

Поскольку в общем случае данный метод не имеет решения, на него налагается огромное кол-во ограничений. В результате:

+ Справляется с некоторыми формулами, содержащими умножение, при задаваемых значениях не кратных множителю,с которыми 
не справляется метод перебора. При этом он выдает округленное значение, а не ошибку. Например:

    d0*10

- Не справляется с некоторыми формулами, содержащими умножение, с котороми справляется метод перебора, например:

    (3*d0 - 38) / 7

+ В отличие от метода перебора, справляется с формулами с 4-я байтами данных.

- Возникают ошибки с некоторыми операторами в формулах, в которых операндами оператора являются другие операнды.

## Описание особенностей реализации функции DoReverseCalculateWithTree()

Для выполнения данного метода, необходимо сначала построить дерево, соответствующее формуле c помощью функции- [CreateTree()](https://github.com/PonomarevDA/Parser/blob/c7f0cda16bb13a00426681c0618f01184bc1e3de/obd.cpp#L6-L64)

Данный метод является рекурсивным. Вызов происходит с подачей единственного аргумента - "ответа" [см. введение].

Второй аргумент функции при первом вызове не указывается, указатель на узел инициализируется указателем на базовый узел.

Анализируются потомки данного узла и выполняются действия в зависимости от возможных ситуаций.

Если операторов в формуле больше одного, функция рекурсивно вызывает сама себя, однако вторым аргументом функции является указатель 
на потомка-оператора.

Введем понятия элементарного обратного расчета - расчет, который применяется для выражений вида

    10 * x = value,

т.е. минимальный расчет выражения с хотя бы одним константным операндом (или байтом данных).

Элементарный обратный расчет реализует функция [CalculateReverseElementary](https://github.com/PonomarevDA/Parser/blob/c7f0cda16bb13a00426681c0618f01184bc1e3de/obd.cpp#L420-L523)

Рассмотрим бинарный оператор. Возможны 9 вариантов потомков. 
1. const, const;
2. const, data;
3. const, operator;
4. data, const;
5. data, data;
6. data, operator;
7. operator, const;
8. operator, data;
9. operator, operator;

Разобьем их на 4 группы:

**1.Достаточно прямого расчета**
- const, const

@ return value - результат прямого расчета

**2.Необходим обратный элементарный расчет:**
- (const, data) и (data, const) - необходим и достаточен элементарный обратный расчет;
- (const, operator) и (operator, const) - необходим элементарный обратный расчет и вызов функции Do...() для оператора;
- (data, operator) и (operator, data) - для оператора также необходим вызов функции Do...(), для байта данных расчет очень сложен;

@ return value - значение неизвестного операнда

**3.Необходимо сложное решение:**
- operator, operator

Примечание: для каждого оператора рекурсивно вызывается по функции Do().

**4.Решение найти слишком сложно или невозможно:**
- data, data

В зависимости от того, какая группа потомков у данного узла, выполняется вызов следующих функций:
- DoReverseCalculateWithTree;
- CalculateReverseElementary;
- CalculateDirectElementary;
