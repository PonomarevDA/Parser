# Parser. Дерево синтаксического разбора

## Введение
Рассмотрим следующую ситуацию: есть некоторая известная формула с несколькими переменными. Подстановкой значений этих переменных в данную
формулу можно однозначно получить ответ (число).
Введем 2 понятия:

1. Прямая задача - когда известны формула и переменные, и нужно найти ответ. Такую задачу решает терминал.
2. Обратная задача - когда известны формула и ответ, нужно найти значения переменных. Такую задачу решает стенд.

В общем случае вторая задача не имеет решения, поскольку теоретически могут возникнуть нерешаемые формулы вида:

    d0 + d1 = value,

где d0 и d1 - переменные, а value - ответ.

На практике формулы будут иметь однозначные решения, однако замечены исключения.

## Описание файлов и их применения

Предполагается, что данный код будет интегрирован в прошивку стенда, а именно в функции файла obd.cpp:

- Init() - инициализация  протокола obd, парсер формул из конфигуратора. Сюда будет включена функция [CreateTree()](https://github.com/PonomarevDA/Parser/blob/7d7a16e797d3689aac5a465f93a23d8b85e6dacc/obd.cpp#L49-L101)

- Do() - обработка текущего состояния. В эту функцию будет включен один из методов DoReverseCalculate...(), которые описаны ниже

Список файлов с кратким описание представлен в таблице 1.

*Таблица 1.*

| Файл                | Краткое описание   |
| ------------------- |:------------------:|
| obd.cpp и .hpp      | Файлы с инициализацией исходных данных и реализацией методов прямого и обратного расчета |
| obd_test.cpp и .hpp | Файлы с тестовыми кейсами данных методов                                                 |
| data_structures.hpp | Заголовочный файл со структурами данными, подключен в файл obd.cpp                       |
| tree.cpp            | Реализация методов класса Tree                                                           |
| stack.cpp           | Реализация методов класса Stack                                                          |


Для проведения тестов вне стенда создан класс TestOBD.

Чтобы им воспользоваться, достаточно создать пустой проект, добавить в него все указанные в таблице файлы, создать main.cpp файл,
подключить к нему все заголовочные файлы, в main() функции создать объект класса TestOBD и вызвать метод TestCalculationReverse(). 

    #include "data_structures.hpp"
    #include "obd.hpp"
    #include "obd_test.hpp"

    int main()
    {
        TestOBD testOBD;
        testOBD.TestCalculationReverse();
    }

## Описание дерева

Дерево представляет из себя набор узлов - структур, обладающих следующими полями:

1. Value - байт формулы;

2. ChildsCount - кол-во потомков;

3. ChildsArr - указатель на указатель узлов-потомков;

4. Parent - указатель на узел-потомка. Если родителя нет, то указывает на nullptr.

Дерево строится в порядке, обратном расположению элементов массива байт Formula, т.е. начиная со старшего элемента.

Вводятся следующие понятия во избежаении путаницы:

- Базовый узел (base) - родитель всех родителей или узел (обычно оператор), с которого начинается решение обратной задачи расчета.

- Висячий узел (apex) - узел, который связан только с одним другим узлом. Графически висячие узлы располагаются на самом нижнем уровне, поскольку не имеют потомков. Данные узлы являются операндами.


## Описание методов решения обратной задачи

Предлагается 3 метода решения обратной задачи:



**1 Метод перебора [DoReverseCalculateWithBruteForce()](https://github.com/PonomarevDA/Parser/blob/7d7a16e797d3689aac5a465f93a23d8b85e6dacc/obd.cpp#L272-L301)**

Из 8-и переменных типа uint8_t в формулах могут присутствовать не более 4-ех.

+Данный метод позволяет найтии решение обратной задачи. В случае, если решение не единственное, он вернет первое найденное решение.

-Максимальное время решения задачи данным методом для 3-ех переменных ~ 7 секунд. Для 4-ех переменных время не измерялось...



**2 Метод половинного деления [DoReverseCalculateWithMethodDichotomy()](https://github.com/PonomarevDA/Parser/blob/7d7a16e797d3689aac5a465f93a23d8b85e6dacc/obd.cpp#L304-L344)**

Данный метод можно заменить, например, на метод золотого сечения, тем самым сделать его еще более быстрым.

+Если возможно (в 50% случаев), очень быстро находит решение.

-В ситуаях, когда функция не монотонна, метод может не найти решения и зависнуть. Пример подобных формул:

    (d0 == 10) && (d0 == 20)



**3 Метод решения обратной задачи с помощью дерева [DoReverseCalculateWithTree()](https://github.com/PonomarevDA/Parser/blob/7d7a16e797d3689aac5a465f93a23d8b85e6dacc/obd.cpp#L173-L269)**

Для выполнения данного метода, необходимо сначала построить дерево, соответствующее формуле c помощью функции- [CreateTree()](https://github.com/PonomarevDA/Parser/blob/7d7a16e797d3689aac5a465f93a23d8b85e6dacc/obd.cpp#L49-L101)

Данный метод является рекурсивным. Вызов происходит с подачей единственного аргумента - "ответа" [см. введение].

Поскольку второй аргумент функции при вызове не указан, указатель на узел инициализируется указателем на базовый узел.

Анализируются потомки данного узла и выполняются действия в зависимости от возможных ситуаций.

Если операторов в формуле больше одного, функция рекурсивно вызывает сама себя, однако вторым аргументом функции является указатель 
на потомка-оператора.



## Описание особенностей реализации функции DoReverseCalculateWithTree()

Введем понятия элементарного обратного расчета - расчет, который применяется для выражений вида

    10 * x = value,

т.е. минимальный расчет выражения с хотя бы одним константным операндом (или байтом данных).

Элементарный обратный расчет реализует функция [CalculateReverseElementary](https://github.com/PonomarevDA/Parser/blob/7d7a16e797d3689aac5a465f93a23d8b85e6dacc/obd.cpp#L392-L487)

Рассмотрим бинарный оператор. Возможны 9 вариантов потомков. 
1. const, const;
2. const, data;
3. const, operator;
4. data, const;
5. data, data;
6. data, operator;
7. operator, const;
8. operator, data;
9. operator, operator;

Разобьем их на 4 группы:

**1.Достаточно прямого расчета**
- const, const

@ return value - результат прямого расчета

**2.Необходим обратный элементарный расчет:**
- (const, data) и (data, const) - необходим и достаточен элементарный обратный расчет;
- (const, operator) и (operator, const) - необходим элементарный обратный расчет и вызов функции Do...() для оператора;
- (data, operator) и (operator, data) - для оператора также необходим вызов функции Do...(), для байта данных расчет очень сложен;

@ return value - значение неизвестного операнда

**3.Необходимо сложное решение:**
- operator, operator

Примечание: для каждого оператора рекурсивно вызывается по функции Do().

**4.Решение найти слишком сложно или невозможно:**
- data, data

В зависимости от того, какая группа потомков у данного узла, выполняется вызов следующих функций:
- DoReverseCalculateWithTree;
- CalculateReverseElementary;
- CalculateDirectElementary;
