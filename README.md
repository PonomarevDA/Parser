# Parser. Дерево синтаксического разбора

## Введение
Рассмотрим следующую ситуацию: есть некоторая известная формула с несколькими переменными. Подстановкой значений этих переменных в данную
формулу можно однозначно получить ответ (число).
Введем 2 понятия:

1. Прямая задача - когда известны формула и переменные, и нужно найти ответ. Такую задачу решает терминал.
2. Обратная задача - когда известны формула и ответ, нужно найти значения переменных. Такую задачу решает стенд.

В общем случае вторая задача не имеет решения, поскольку теоретически могут возникнуть нерешаемые формулы вида:

    d0 + d1 = value,

где d0 и d1 - переменные, а value - ответ.

На практике формулы будут иметь однозначные решения, однако замечены исключения.

## Описание методов решения обратной задачи

Предлагается 3 метода решения обратной задачи:



**1 Метод перебора [Do_reverse_calculate_with_brute_force()](https://github.com/PonomarevDA/Parser/blob/253431dfb9348989018661747b2fec71a4966647/obd.cpp#L247-L276) )**

Из 8-и переменных типа uint8_t в формулах могут присутствовать не более 4-ех.

+Данный метод позволяет найтии решение обратной задачи. В случае, если решение не единственное, он вернет первое найденное решение.

-Максимальное время решения задачи данным методом для 3-ех переменных ~ 7 секунд. Для 4-ех переменных время не измерялось...



**2 Метод половинного деления [method dichotomy()](https://github.com/PonomarevDA/Parser/blob/253431dfb9348989018661747b2fec71a4966647/obd.cpp#L279-L321)**

Данный метод можно заменить, например, на метод золотого сечения, тем самым сделать его еще более быстрым.

+Если возможно (в 50% случаев), очень быстро находит решение.

-В ситуаях, когда функция не монотонна, метод может не найти решения и зависнуть. Пример подобных формул:

    (d0 == 10) && (d0 == 20)



**3 Метод решения обратной задачи с помощью дерева [Do_reverse_calculate_with_tree()](https://github.com/PonomarevDA/Parser/blob/253431dfb9348989018661747b2fec71a4966647/obd.cpp#L157-L244)**

Для выполнения данного метода, необходимо сначала построить дерево, соответствующее формуле c помощью функции- [create_tree()](https://github.com/PonomarevDA/Parser/blob/253431dfb9348989018661747b2fec71a4966647/obd.cpp#L33-L85)

Данный метод является рекурсивным. Вызов происходит с подачей единственного аргумента - "ответа" [см. введение].

Поскольку второй аргумент функции при вызове не указан, указатель на узел инициализируется указателем на базовый узел.

Анализируются потомки данного узла и выполняются действия в зависимости от возможных ситуаций.

Если операторов в формуле больше одного, функция рекурсивно вызывает сама себя, однако вторым аргументом функции является указатель 
на потомка-оператора.

## Описание файлов и их применения

Предполагается, что данный код будет интегрирован в прошивку стенда, а именно в функции файла obd.cpp:

- init() - инициализация  протокола obd, парсер формул из конфигуратора. Сюда будет включена функция [create_tree()](https://github.com/PonomarevDA/Parser/blob/253431dfb9348989018661747b2fec71a4966647/obd.cpp#L33-L85)

- do() - обработка текущего состояния. В эту функцию будет включен один из методов Do_reverse_calculate...()

Список файлов с кратким описание представлен в таблице 1.

*Таблица 1.*

| Файл                | Краткое описание   |
| ------------------- |:------------------:|
| obd.cpp и .hpp      | Файлы с инициализацией исходных данных и реализацией методов прямого и обратного расчета |
| obd_test.cpp и .hpp | Файлы с тестовыми кейсами данных методов                                                 |
| data_structures.hpp | Заголовочный файл со структурами данными, подключен в файл obd.cpp                       |
| tree.cpp            | Реализация методов класса Tree                                                           |
| stack.cpp           | Реализация методов класса Stack                                                          |


Основной файл - obd, предполагается:

## Описание дерева

Дерево представляет из себя набор узлов - структур, обладающих следующими полями:

1. Value - байт формулы;

2. ChildsCount - кол-во потомков;

3. ChildsArr - указатель на указатель узлов-потомков;

4. Parent - указатель на узел-потомка. Если родителя нет, то указывает на nullptr.

Дерево строится в порядке, обратном расположению элементов массива байт Formula, т.е. начиная со старшего элемента.

Вводятся следующие понятия во избежаении путаницы:

- Базовый узел (base) - родитель всех родителей или узел (обычно оператор), с которого начинается решение обратной задачи расчета.

- Висячий узел (apex) - узел, который связан только с одним другим узлом. Формально, под область данного определения может попасть базовый узел, однако, говоря о висячих узлах, будет иметь ввиду все узлы, кроме базового. Графически висячие узлы располагаются на самом нижнем уровне, поскольку не имеют потомков. Данные узлы являются операндами. 
