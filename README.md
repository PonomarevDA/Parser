# Parser. Дерево синтаксического разбора

## Введение
Рассмотрим следующую ситуацию: есть некоторая известная формула с несколькими переменными. Подстановкой значений этих переменных в данную
формулу можно однозначно получить ответ (число).
Введем 2 понятия:

1. Прямая задача - когда известны формула и переменные, и нужно найти ответ. Такую задачу решает терминал.
2. Обратная задача - когда известны формула и ответ, нужно найти значения переменных. Такую задачу решает стенд.

В общем случае вторая задача не имеет решения, поскольку теоретически могут возникнуть нерешаемые формулы вида:

    d0 + d1 = value,

где d0 и d1 - переменные, а value - ответ.

На практике формулы будут иметь однозначные решения, однако замечены исключения.

## Описание методов решения обратной задачи

Предлагается 3 метода решения обратной задачи:



**1 Метод перебора [Do_reverse_calculate_with_brute_force() ](https://github.com/PonomarevDA/Parser/blob/253431dfb9348989018661747b2fec71a4966647/obd.cpp#L247-L276) )**

Из 8-и переменных типа uint8_t в формулах могут присутствовать не более 4-ех.

+Данный метод позволяет найтии решение обратной задачи. В случае, если решение не единственное, он вернет первое найденное решение.

-Максимальное время решения задачи данным методом для 3-ех переменных ~ 7 секунд. Для 4-ех переменных время не измерялось...



**2 Метод половинного деления [method dichotomy](https://github.com/PonomarevDA/Parser/blob/253431dfb9348989018661747b2fec71a4966647/obd.cpp#L279-L321)**

Данный метод можно заменить, например, на метод золотого сечения, тем самым сделать его еще более быстрым.

+Если возможно (в 50% случаев), очень быстро находит решение.

-В ситуаях, когда функция немонотонна, метод может не найти решения и зависнуть. Пример подобных формул:

    (d0 == 10) && (d0 == 20)



**3 Метод решения обратной задачи с помощью дерева [Do_reverse_calculate_with_tree](https://github.com/PonomarevDA/Parser/blob/253431dfb9348989018661747b2fec71a4966647/obd.cpp#L157-L244)

Для выполнения данного метода, необходимо сначала построить дерево, соответствующее формуле c помощью функции- [create_tree](https://github.com/PonomarevDA/Parser/blob/253431dfb9348989018661747b2fec71a4966647/obd.cpp#L33-L85)

Данный метод является рекурсивным. Вызов происходит с подачей единственного аргумента - "ответа" [см. введение].

Поскольку второй аргумент функции при вызове не указан, указатель на узел инициализируется указателем на базовый узел.

Анализируются потомки данного узла и выполняются действия в зависимости от возможных ситуаций.

Если операторов в формуле больше одного, функция рекурсивно вызывает сама себя, однако вторым аргументом функции является указатель 
на потомка-оператора.

## Описание реализации

Несколько файлов

## Описание дерева

Дерево представляет из себя набор узлов, каждый из которых обладае

Основной файл - obd, предполагается:

